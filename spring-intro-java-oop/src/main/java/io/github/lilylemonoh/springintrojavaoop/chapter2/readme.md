# 02 자바와 절차적/구조적 프로그래밍 

## 01_자바 프로그램의 개발과 구동
JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있고, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.
자바 개발자는 본인이 사용 중인 플랫폼에 설치된 JVM용으로 프로그램을 작성하고 배포하면 각 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 프로그램을 구동하는 데 아무 문제가 없게끔
만들어주는 것이다.

## 02_자바에 존재하는 절차적/구조적 프로그래밍의 유산
절차적 프로그래밍을 한바디로 표현하자면 goto를 쓰지 말라는 것이다.
goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문이다.

구조적 프로그래밍은 함수를 쓰라는 것이다. 함수는 중복 코드 제거와 논리를 분할하기 위한 용도다.

자바 언어에서 절차적/구조적 프로그래밍의 유산은 어디 남아 있을까? 
객체 지향 언어에서 절차적/구조적 프로그래밍의 유산은 메서드 안에서 확인할 수 있다.
객체 지향 프로그래밍에서 제어문이 존재할 수 있는 유일한 공간은 바로 메서드 내부이기 때문이다.

## 03_다시 보는 main() 메서드: 메서드 스택 프레임
[예제2-1] Start.java
```java
public class Start {
    public static void main(String[] args) {
        System.ot.println("Hello OOP!!!");
    }
}
```

* 스태틱 영역 - 클래스들의 놀이터
* 스택 영역 - 메서드들의 놀이터
* 힙 영역 - 객체들의 놀이터

1. JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다. main() 메서드의 존재가 확인되면 JVM을 부팅한다.
2. 부팅된 JVM은 목적 파일을 맏아 그 목적 파일을 실행한다.
3. 가장 먼저 전처리를 위해 모든 자바 프로그램이 반드시 포함하는 패키지인 java.lang을 스태틱 영역에 가져다 놓는다.
4. 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 가져다 놓는다.

**main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들**
* java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다.
* import된 패키지를 T 메모리의 스태틱 영역에 배치한다.
* 프로그램상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.

5. main() 메서다그 놀기 위해 스택 프레임(stack frame)이 스택 영역에 할당된다.
   (여는 중괗로를 만날 때마다 스택 프레임이 하나씩 생긴다. 클래스 정의를 시작하는 중괄호 제외.)
6. 메서드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보해야 한다.
7. 구문이 실행되면 T 메모리에는 변화가 없다.
8. main() 메서드의 끝을 나타내는 닫는 중괄호가 실행되면 스택 프레임이 소멸된다.
9. main() 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제상의 메모리에서 사라진다.

## 04_변수와 메모리: 변수! 너 어디 있니?
[예제 2-2]Start2.java
```java
public class Start2 {
    public static void main(String[] args) {
        int i;
        i = 10;

        double d = 20.0;
    }
}

```
이 절의 부제가 "변수! 너 어디있니?"였는데 그 답은 "지역변수와 메모리" 절에서 확인할 수 있다.

## 05_블록 구문과 메모리: 블록 스택 프레임
[예제 2-3] Start3.java
```java
public class Start3 {
    public static void main(String[] args) {
        int i = 10;
        int k = 20;

        if (i == 10) {
            int m = k + 5;
            k = m;
        } else {
            int p = k + 10;
            k = p;
        }

        // k = m + p;
    }
}
```
if 블록 스택 프레임이 존재한다는 사실을 꼭 기억하자.  
if 블록 중 참일 때의 블록을 종료하는 닫는 중괄호를 만나면 if 블록 스택 프레임은 스택 영역에서 사라진다.
이때 if 블록 스택 프레임 안에 상주하던 변수의 저장 공간도 함께 사라진다.  

main() 메서드 스택 프레임을 소멸시키는 블록 마침 기호인 닫는 중괄호를 만나면 T 메모리 소멸, JVM 가동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납하게 된다.


## 06_지역 변수와 메모리: 스택 프레임에 갇혔어요!
지역 변수는 스택 영역에서 일생을 보낸다. 
그것도 스택 프레임 안에서 일생을 보내게 된다. 
따라서 스택 프레임이 사라지면 함께 사라진다.

클래스 멤버 변수는 스태틱 영역에서 일생을 보낸다. 
스태틱 영역에 한번 자리 잡으면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.

객체 멤버 변수는 힙에서 일생을 보낸다. 
객체 멤버 변수들은 객체와 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 일생을 마치게 된다.

> "외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다."


## 07_메서드 호출과 메모리: 메서드 스택 프레임 2
[예제 2-5] Start4.java
```java
public class Start4 {
    public static void main(String[] args) {
        int k = 5;
        int m;
        
        m = square(k);
    }
    
    private static int square(int k) {
        int result;
        k = 25;
        result = k;
        return result;
    }
}
```
메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달한다.
이런 전달 방식을 값에 의한 정달이라고 해서 Call By Value라고 한다.

메서드 사이에 값을 전달하거나 반환하는 방법은 메서드의 인자와 반환값으로만 가능하다는 사실을 기억해 두자.
물론 전역변수(공유 변수)도 있긴 하지만 가급적 전역 변수는 쓰지 않는 것이 좋다.

## 08_전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
[예제 2-6] Start5.java
```java
public class Start5 {
    static int share;

    public static void main(String[] args) {
        share = 55;
        
        int k = fun(5, 7);

        System.out.println(share);
    }
    
    private static int fun(int m, int p) {
        share = m + p;
        
        return m - p;
    }
}

```
전역 변수는 피할 수 있다면 즐기지 말고 피해야 할 존재다. 
다만 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 적극 추천한다.

## 09_멀티 스레드 / 멀티 프로세스의 이해

멀티 스레드(Multi Thread)의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.  
멀티 프로세스(Multi Process)는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.

멀티 프로세스는 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다. 
그에 반해 멀티 스레드는 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다.

멀티 프로세스는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만
메모리 사용량은 그만큼 크다.

멀티 스레드는 하나의 T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의
스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다.
따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.

자바 웹 프로그래밍을 공부해 본 적이 있다면 서블릿은 요청당 프로세스가 아닌 요청당 스레드를 생성한다는 말이
머릿속 어딘가에 콕 박혀 있을 것이다.

[예제 2-7] Start6.java
```java
public class Start6 extends Thread{
   static int share;

   public static void main(String[] args) {
      Start6 t1 = new Start6();
      Start6 t2 = new Start6();

      t1.start();
      t2.start();
   }

   public void run() {
      for (int count = 0; count < 10; count++) {
         System.out.println(share++);

         try { sleep(1000); }
         catch (InterruptedException e) {}
      }
   }
}
```
(추가 설명 - sleep을 100으로 줄였을 때 문제점이 드러났음.)

## 10_STS(또는 이클립스)를 이용해 T 메모리 영역 엿보기
절차적/구조적 프로그래밍에서 공유 변수를 필드라고 불렀고 기능적 요소를 함수라고 불렀다. 
객체 지향 프로그래밍에서 같은 일을 하지만 이름을 그대로 따라 쓰자니 차별화가 안 되는 것 같았다고 한다.
그래서 객체 지향에서는 전역 변수를 프로퍼티라 부르고, 함수를 메서드라 부르기 시작했다고 한다.

## 11_정리 - 객체 지향은 절차적/구조적 프로그래밍의 어깨를 딛고
메서드를 만들 때는 순서도 또는 의사 코드를 작성하는 것이 좋다. 
필자가 가장 좋아하는 메서드의 로직 설계 방법은 NS 다이어그램이다.